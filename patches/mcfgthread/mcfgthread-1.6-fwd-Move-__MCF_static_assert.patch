From c4f164cac9d6022ae327b31147106d8ff9c27ac2 Mon Sep 17 00:00:00 2001
From: LIU Hao <lh_mouse@126.com>
Date: Fri, 3 May 2024 17:34:49 +0800
Subject: [PATCH] fwd: Move `__MCF_static_assert<true>` into an `extern "C++"`
 block

This is not allowed as per C++11:

  7.1.1 Storage class specifiers [dcl.stc]
  1. ... A storage-class-specifier shall not be specified in an explicit
     specialization (14.7.3) or an explicit instantiation (14.7.2) directive.

Reference: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=114933
Signed-off-by: LIU Hao <lh_mouse@126.com>
(cherry picked from commit 86ea295e41523183e7680c03cab35e6eb74c4857)
Signed-off-by: LIU Hao <lh_mouse@126.com>
---
 mcfgthread/fwd.h | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/mcfgthread/fwd.h b/mcfgthread/fwd.h
index c6d407c5..0b4b1bc6 100644
--- a/mcfgthread/fwd.h
+++ b/mcfgthread/fwd.h
@@ -109,8 +109,10 @@ __MCF_C_DECLARATIONS_BEGIN
 /* The `__MCF_STATIC_ASSERT_0()` macro is an expression that yields zero if it
  * compiles anyway. Its argument must be a constant expression.  */
 #ifdef __cplusplus
-extern "C++" template<bool> struct __MCF_static_assert;
-extern "C++" template<> struct __MCF_static_assert<true> { };
+extern "C++" {
+template<bool> struct __MCF_static_assert;
+template<> struct __MCF_static_assert<true> { };
+}  /* extern "C++"  */
 #  define __MCF_STATIC_ASSERT_T(...)   ::__MCF_static_assert<bool(__VA_ARGS__)>
 #else
 #  define __MCF_STATIC_ASSERT_T(...)   struct { int: 1|-!(__VA_ARGS__); }
